---
title: "Version control"
author: "Stas Kolenikov"
date: "`r Sys.Date()`"
# output: ioslides_presentation
output:
  rmdshower::shower_presentation:
    self_contained: false
    katex: true
    ratio: 16x10
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Version control

Wikipedia [defines](https://en.wikipedia.org/wiki/Version_control) version control as

> management of changes to documents, computer programs, 
> large web sites, and other collections of information. 

To put it differently, this is a way to retain semblance of sanity 
when the inputs and the code keeps changing.

## Concepts

The major concepts concerning version control are:

1. Repository
2. Changeset
3. Commits
4. Distributed VCS: push/pull/merge

## Repository

It is easiest to think about repositories as projets. It is best to keep 1:1 relations between them,
although you can try more complicated relations with several code repositories within a project,
or, worse, a single repository serving different projects.

A repository is a collection of:

- files that you are working on, such as code or input data
- metadata about these files, namely the record of changes

## Stas' ongoing example: `ipfraking` repo

https://bitbucket.org/stas_kolenikov/ipfraking

## Changeset

A changeset is a record in the repository of the changes that were made to its state.

Each changeset is assigned a random hex string, usually of at least a dozen characters, if not two dozen,
to uniquely identify it.

## Commits

Once the code developer decides they have made a reasonable number of changes, 

Commit is the action of adding a changeset to the repository.

In every VCS, a commit message is required to accompany the commit and 
describe what this commit/changeset achieves.

## Scope

What's an appropriate scope for a changeset? Well, ideally, whatever you can describe in 
one sentence that would be visible when you view your repo!

> A matching bracket is fixed in `load_data.py`

or can be 

> Web scraping code is added

which could add 25 files to the repo -- but this would still be a good changeset with a specific purpose. 

## Stas' ongoing example: a random changeset in `ipfraking`

https://bitbucket.org/stas_kolenikov/ipfraking/commits/e069eb8cded6d3454efab9adcb60e4c415cd7ba1

Go back to the list of commits to see how the commit message is displayed

https://bitbucket.org/stas_kolenikov/ipfraking/commits/all

## Branches 

Distributed VCSs allow different users/developers to work on their part of the project
independently. E.g., one team could work on the engine, another on inputs in the user interface, 
and yet another on the outputs. In analytic projects, some people may be working on data
acquisition and cleaning, while others could prepare analysis templates and narratives
(in markdown).

## Push/pull

Each user can work on their own copy of the repository, making commits to that copy.
However, periodically (EOB? end of the week?) everybody need to synchronize their state of the
project to make sure that the different pieces really work together. To that effect,
distrbiuted VCS have two specific actions: *push* and *pull*.

## Push/pull

- *push* is the action of uploading your local commits (all of them) to the centralized, master
copy of the repository (typically, a repository on GitHub.com, BitBucket.org, Kiln on FogCreek, etc.)
- *pull* is the action of downloading the commits from the master repository to your own local copy

TODO: insert a cute picture of a branched repo.

## Merge

As you can clearly imagine, push/pull operation can easily create conflicts.
What if two or more different people made changes between their respective
pushes to the master repository? What should the resulting state be after all developers
push their code?

The issue is known as *merge*. Sometimes, merges are clean -- i.e., when different people
worked on different files, or each file was worked on by one person at a time.

## Merge

Other times, merges require intervention of a knowledgeable human to determine how 
the conflicts are to be resolved. Typically, VCS clients (see below) offer meaningful options,
e.g., by taking the union of the changes. But sometimes, manual editing may be required
when e.g. different developers worked on the same file.

TODO: insert a cute picture of a branched repo with merges.

## Example of a merge in `ipfraking` repo

https://bitbucket.org/stas_kolenikov/ipfraking/commits/6a43bf36b4b84f03a25da20ac1e477e8433df437

## Issue tracking

While not necessarily a part of a version control system, *issue trackers*
are a useful addition to them. When you see an email from your IT support titled like
"*Ticket #1054347: Excel does not open on my computer*", it is generated by
the issue tracking system that your IT uses.

- a bug (most typical in software development)
- a task (e.g., consolidating or refactoring the code)
- an enhancement or a feature request

## Analysis plan in issue trackers

In the world of data analytic projects, an analysis plan can be converted
to a series of "issues", with subsequent development of the code addressing,
and closing, these issues.

## Issue trackers and commit messages

A neat way to bring together the concepts of commits and issues is through 
markup of commit messages. Typically, the following conventions are understood 
by the different VCS:

- a hash sign # denotes an issue
- a hex string denotes a changeset
- text like "*fixed*" or "*resolved*"

## There, I fixed it for you

Most modern VCS would be able to parse the message

> Commit 45ef0da2c fixes issue # 237: input file is not updated in code/refresh_plot.py 

and identify all three components: the changeset, the issue, and the file. Moreover,
the issue will get closed/resolved automatically with such a commit message.

## VCS wars

There are three major version control systems:

1. [Git](https://git-scm.com/)
1. [Mercurial/Hg](https://www.mercurial-scm.org/)
1. Apache [Subversion/SVN](https://subversion.apache.org/)

They share the common functionality, and while the differences are mostly in esoteric issues,
these differences divide the developers into intensely loyal camps.

## Client wars

But there is more. While version control *engines* run from command line, there are also neat
GUIs, or clients, to visualize the processes --- and they cause wars, too.

1. Atlassian [SourceTree](https://www.sourcetreeapp.com/) -- supports both Git and Mercurial
1. [TortoiseHg](https://tortoisehg.bitbucket.io/) -- Mercurial only
1. [GitKraken](https://www.gitkraken.com/) -- Git only

and many others. They obviously differ somewhat in what they can do, and which of the more
complex functions are supported.

## Time to play!

Enough said! Let's go break some things!

Prerequisites:

- an account on https://github.com or https://bitbucket.org
- a VCS client -- any one mentioned on the previous slide
  * RStudio has a built-in Git client, too
- desire to learn!

## Exercise 1: create a repo

For a number of reasons, a better workflow is to create a repository online first,
and then fold it into your local work. So, create a repository (let's name it `sandbox`)
on GitHub or BitBucket, depending on where you have an account.

